import { NextRequest, NextResponse } from "next/server"
import { promises as fs } from "fs"
import path from "path"

interface FixSEORequest {
  issueType: "missingTitle" | "missingDescription"
  pagePath: string
  fileLocation: string
  currentContent?: string
}

interface FixSEOResponse {
  success: boolean
  fixedContent?: string
  error?: string
}

export async function POST(request: NextRequest) {
  try {
    const body: FixSEORequest = await request.json()
    const { issueType, pagePath, fileLocation, currentContent } = body

    // Check if OpenAI API key is available
    const openaiApiKey = process.env.OPENAI_API_KEY
    if (!openaiApiKey) {
      return NextResponse.json(
        { success: false, error: "OpenAI API key not configured" },
        { status: 400 }
      )
    }

    // Read the current file content
    const filePath = path.join(process.cwd(), fileLocation)
    let fileContent: string
    try {
      fileContent = await fs.readFile(filePath, 'utf-8')
    } catch (error) {
      return NextResponse.json(
        { success: false, error: `Failed to read file: ${filePath}` },
        { status: 404 }
      )
    }

    // Generate SEO content using OpenAI
    const seoContent = await generateSEOContent(openaiApiKey, issueType, pagePath, fileContent)

    if (!seoContent) {
      return NextResponse.json(
        { success: false, error: "Failed to generate SEO content" },
        { status: 500 }
      )
    }

    // Update the file with the new SEO content
    const updatedContent = updateFileWithSEO(fileContent, issueType, seoContent, pagePath)
    
    // Write the updated content back to the file
    await fs.writeFile(filePath, updatedContent, 'utf-8')

    return NextResponse.json({
      success: true,
      fixedContent: updatedContent,
      message: `Successfully fixed ${issueType} for ${pagePath}`
    })

  } catch (error) {
    console.error("[Fix SEO API] Error:", error)
    return NextResponse.json(
      { 
        success: false, 
        error: "Failed to fix SEO issue",
        details: error instanceof Error ? error.message : "Unknown error"
      },
      { status: 500 }
    )
  }
}

async function generateSEOContent(
  apiKey: string, 
  issueType: string, 
  pagePath: string, 
  fileContent: string
): Promise<string | null> {
  try {
    // Extract page context from the file content
    const pageContext = extractPageContext(fileContent, pagePath)
    
    const prompt = issueType === "missingTitle" 
      ? generateTitlePrompt(pagePath, pageContext)
      : generateDescriptionPrompt(pagePath, pageContext)

    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${apiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        model: "gpt-4o-mini",
        messages: [
          {
            role: "system",
            content: "You are an expert SEO specialist for KiteSafaris.com, a kiteboarding adventure company. Generate concise, engaging, and SEO-optimized content that matches the brand voice and includes relevant keywords."
          },
          {
            role: "user",
            content: prompt
          }
        ],
        max_tokens: 150,
        temperature: 0.7,
      }),
    })

    if (!response.ok) {
      throw new Error(`OpenAI API error: ${response.status}`)
    }

    const data = await response.json()
    const generatedContent = data.choices?.[0]?.message?.content?.trim()
    
    if (!generatedContent) {
      throw new Error("No content generated by OpenAI")
    }

    return generatedContent

  } catch (error) {
    console.error("Error generating SEO content:", error)
    return null
  }
}

function extractPageContext(fileContent: string, pagePath: string): string {
  // Extract relevant context from the file content
  const lines = fileContent.split('\n')
  let context = ""
  
  // Look for component names, imports, and other relevant content
  for (const line of lines) {
    if (line.includes('export default') || line.includes('function') || line.includes('const')) {
      context += line + " "
    }
    if (line.includes('className') || line.includes('text-')) {
      context += line + " "
    }
  }
  
  return context.substring(0, 500) // Limit context length
}

function generateTitlePrompt(pagePath: string, pageContext: string): string {
  const pageName = pagePath.split('/').pop() || pagePath.replace('/', '')
  
  return `Generate a compelling, SEO-optimized page title for the KiteSafaris.com page: ${pagePath}

Page context: ${pageContext}

Requirements:
- Include relevant keywords like "kiteboarding", "kite safari", "Caribbean", "Antigua", etc.
- Keep it under 60 characters
- Make it engaging and descriptive
- Include the brand name "KiteSafaris" when appropriate
- Focus on the main value proposition of the page

Return only the title text, no quotes or additional formatting.`
}

function generateDescriptionPrompt(pagePath: string, pageContext: string): string {
  const pageName = pagePath.split('/').pop() || pagePath.replace('/', '')
  
  return `Generate a compelling, SEO-optimized meta description for the KiteSafaris.com page: ${pagePath}

Page context: ${pageContext}

Requirements:
- Include relevant keywords like "kiteboarding", "kite safari", "Caribbean", "Antigua", etc.
- Keep it under 160 characters
- Make it engaging and include a call-to-action
- Focus on the main value proposition of the page
- Include the brand name "KiteSafaris"

Return only the description text, no quotes or additional formatting.`
}

function updateFileWithSEO(
  fileContent: string, 
  issueType: string, 
  seoContent: string, 
  pagePath: string
): string {
  const lines = fileContent.split('\n')
  const updatedLines: string[] = []
  let inMetadata = false
  let metadataUpdated = false

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i]
    
    // Check if we're entering metadata section
    if (line.includes('export const metadata') || line.includes('export const generateMetadata')) {
      inMetadata = true
      updatedLines.push(line)
      continue
    }

    // If we're in metadata section
    if (inMetadata) {
      // Check if we're exiting metadata (closing brace)
      if (line.trim() === '}' && !line.includes('{')) {
        inMetadata = false
        updatedLines.push(line)
        continue
      }

      // Check for existing title or description
      if (issueType === "missingTitle" && line.includes('title:')) {
        // Replace existing title
        updatedLines.push(`  title: "${seoContent}",`)
        metadataUpdated = true
        continue
      } else if (issueType === "missingDescription" && line.includes('description:')) {
        // Replace existing description
        updatedLines.push(`  description: "${seoContent}",`)
        metadataUpdated = true
        continue
      }

      updatedLines.push(line)
    } else {
      updatedLines.push(line)
    }
  }

  // If we didn't find existing metadata to update, add it
  if (!metadataUpdated && inMetadata) {
    // Find the last line before the closing brace and add our content
    for (let i = updatedLines.length - 1; i >= 0; i--) {
      if (updatedLines[i].trim() === '}') {
        const indent = updatedLines[i - 1]?.match(/^\s*/)?.[0] || '  '
        const newLine = issueType === "missingTitle" 
          ? `${indent}title: "${seoContent}",`
          : `${indent}description: "${seoContent}",`
        
        updatedLines.splice(i, 0, newLine)
        break
      }
    }
  }

  return updatedLines.join('\n')
}
